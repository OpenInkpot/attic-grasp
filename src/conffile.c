/*
 *  Copyright (C) 2003 Alexander Shishckin
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * config.c
 * Global configuration parser
 */

#include "common.h"
#include "config.h"

static config_t *config[MAX_CONFIG_FILES];

/*#define CHECK_CONFIG(__n) (if (!config[__n]) return NO_CONFIG;)*/

static int config_item_init(int n, US line)
{
	config_item_t   *item;
	US              tokens[CONFIG_TOKENS];
	int             i;

	if (!config[n]) return NO_CONFIG;

	item = malloc(sizeof(config_item_t));
	memset(tokens, 0, sizeof(tokens));
	i = 0;
	tokens[i] = (US) strtok((SU)line, " ");
	while ((tokens[++i] = (US)strtok(NULL, " ")));
	
	item->name = malloc(ustrlen((SU)tokens[0]) + 1);
	strcpy((SU)item->name, (SU)tokens[0]);
	item->values = i-1;
	item->next = NULL;
	item->prev = NULL;

	item->value = malloc(sizeof(char *) * item->values);
	for (i = 1; i <= item->values; i++) {
		item->value[i-1] = malloc(ustrlen((SU)tokens[i])+1);
		strcpy((SU)item->value[i-1], (SU)tokens[i]);
	}
	
	if (config[n]->first_item) {
		config[n]->last_item->next = item;
		item->prev = config[n]->last_item;
		config[n]->last_item = item;
	} else {
		config[n]->first_item = item;
		config[n]->last_item  = item;
	}

	return 0;
}

int config_read(US file)
{
	FILE            *fh;
	UC              line[CONFIG_LINE_LENGTH];
	config_item_t   *current;
	int             i = 0;

	while (i < MAX_CONFIG_FILES && config[i]) i++;
	if (i == MAX_CONFIG_FILES) return TOO_MANY_CONFIGS;
	
	config[i] = malloc(sizeof(config_t));
	current = NULL;
	config[i]->first_item = NULL;
	config[i]->last_item  = NULL;
	if (file) {
		config[i]->path = malloc(ustrlen((SU)file) + 1);
		strcpy((SU)config[i]->path, (SU)file);
	}

	fh = fopen((SU)config[i]->path, "r");
	if (!fh) return -ENOENT;

	/*while (fgets((SU)line, CONFIG_LINE_LENGTH, fh)) {*/
	while (!feof(fh)) {
		fgets(line, CONFIG_LINE_LENGTH, fh);
		line[ustrlen((SU)line)-1] = ' ';
		switch(*line) {
			case '#':
			case '\n': /* this is a comment, let's skip it */
				break;
			case '\t':
			case ' ': /* continued values list, todo in future */
				break;
			default:
				config_item_init(i, line);
				break;
		}
	}
	fclose(fh);

	return i;
}

config_item_t *config_item_search(int n, US name)
{
	config_item_t *item;

	if (!config[n]) return NULL;
	
	item = config[n]->first_item;
	while (item && ustrcmp((SU)item->name, name)) { /* , ustrlen(name) */
		item = item->next;
	}

	if (item)
		return item;
	else
		return NULL;
}

int config_write(int n, US filename)
{
	FILE *out;
	config_item_t *item;
	int i;

	if (!config[n]) return GE_ERROR;

	out = fopen(filename, "w");
	if (!out)
		return GE_ERROR;

	fprintf(out, "# Automatically generated by %s\n",
		PACKAGE_NAME);

	item = config[n]->first_item;
	do {
		fputs(item->name, out);
		for (i = 0; i < item->values; i++)
			fprintf(out, " %s", item->value[i]);
		fputc('\n', out);
		item = item->next;
	} while (item != config[n]->last_item);

	fclose(out);

	return GE_OK;
}

int config_item_del(int n, config_item_t *item)
{
	config_item_t	*last;
	int				i;
	
	if (!config[n]) return NO_CONFIG;

	last = config[n]->first_item;
	while (last && last != item)
		last = last->next;
	if (last) {
		if (config[n]->first_item == last)
			config[n]->first_item = last->next;
		if (config[n]->last_item == last)
			config[n]->last_item = last->prev;
		if (last->prev)
			last->prev->next = last->next;
		if (last->next)
			last->next->prev = last->prev;
		
		for (i = 0; i < last->values; i++)
			free(last->value[i]);
		free(last->value);
		free(last->name);
		free(last);
	}
	return 0;
}

int config_get_item_values(int n, US name)
{
	config_item_t *item;

	if (!config[n]) return NO_CONFIG;
	
	item = config_item_search(n, name);
	if (item)
		return item->values;
	else
		return 0;
}

US config_get_item_value(int n, US name, int no)
{
	config_item_t *item;

	item = config_item_search(n, name);
	if (item) {
		if (no < item->values)
			return item->value[no];
		else
			return item->value[item->values-1];
	} else
		return NULL;
}

int config_dispose(int n)
{
	config_item_t *item;

	if (!config[n]) return NO_CONFIG;

	item = config[n]->first_item;
	while (config[n]->first_item)
		config_item_del(n, config[n]->last_item);
	return 0;
}

/* ~/.grasp */
static int global_config;

global_config_t CONFIG;

int global_config_init()
{
	char *homedir = getenv("HOME");
	char confpath[FILENAME_MAX];

	snprintf(confpath, FILENAME_MAX, "%s/.grasp", homedir);
	global_config = config_read(confpath);
	if (global_config < 0) {
		printf("No config file found, expected: %s\n", confpath);
		return -ENOENT;
	}

	/* validate the global config file */
	CONFIG_VALIDATE_OPT(CONFIG.gitbase_url, global_config, "gitbase_url");
	CONFIG_VALIDATE_OPT(CONFIG.gitrepos_dir, global_config, "gitrepos_dir");
	CONFIG_VALIDATE_OPT(CONFIG.tarballs_dir, global_config, "tarballs_dir");
	CONFIG_VALIDATE_OPT(CONFIG.reget_grasp, global_config, "reget_grasp");

	return 0;
}

